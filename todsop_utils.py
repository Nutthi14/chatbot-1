import io
import contextlib
import re


class CodeExecutor:
    """Utility class for executing validated Python code."""

    SAFE_MODULES = {
        'math': __import__('math'),
        'statistics': __import__('statistics'),
    }

    @staticmethod
    def execute_safe_code(code, allowed_keywords, context=None):
        """
        Execute the Python code safely within a restricted context.

        Args:
            code (str): The Python code to execute.
            allowed_keywords (list): A list of keywords allowed in the code.
            context (dict): A dictionary of safe variables/functions to use during execution.

        Returns:
            str: The output generated by the executed code.

        Raises:
            ValueError: If the code contains disallowed operations.
            RuntimeError: If an error occurs during code execution.
        """
        if not CodeExecutor._validate_code_keywords(code, allowed_keywords):
            raise ValueError("Code contains disallowed operations or keywords.")

        # Merge provided context with predefined safe modules
        execution_context = {**CodeExecutor.SAFE_MODULES, **(context or {})}

        try:
            with io.StringIO() as buf, contextlib.redirect_stdout(buf):
                exec(code, execution_context)
                return buf.getvalue()
        except Exception as e:
            raise RuntimeError(f"Error during code execution: {e}\nCode: {code}")

    @staticmethod
    def extract_code_snippet(response):
        """
        Extract the Python code snippet from a response.

        Args:
            response (str): The raw response containing a code block.

        Returns:
            str: The extracted Python code snippet, or the entire response if no snippet is found.
        """
        # Match fenced code blocks (e.g., ```python\n...\n```)
        match = re.search(r'```(?:python|code)?\n(.*?)\n```', response, re.DOTALL)
        if match:
            return match.group(1).strip()

        # Fallback: Look for indented code blocks (common in some plain-text responses)
        match = re.search(r'(?m)^ {4}(.*)$', response)
        if match:
            return "\n".join(line.strip() for line in response.splitlines() if line.startswith('    '))

        # Default to returning the raw response
        return response.strip()

    @staticmethod
    def _validate_code_keywords(code, allowed_keywords):
        """
        Validate that the code contains only allowed keywords.

        Args:
            code (str): The Python code to validate.
            allowed_keywords (list): A list of keywords allowed in the code.

        Returns:
            bool: True if the code passes validation, False otherwise.
        """
        # Combine the allowed keywords into a regex pattern for validation
        keyword_pattern = re.compile(r'\b(?:' + '|'.join(re.escape(keyword) for keyword in allowed_keywords) + r')\b')
        matches = keyword_pattern.findall(code)

        # Ensure all found keywords are in the allowed list
        return bool(matches) and all(keyword in allowed_keywords for keyword in matches)

    @staticmethod
    def log_execution(code, output):
        """
        Log the executed code and its output for traceability.

        Args:
            code (str): The executed Python code.
            output (str): The output generated by the code.
        """
        print("---- Executed Code ----")
        print(code)
        print("---- Execution Output ----")
        print(output)


# Example Usage:
if __name__ == "__main__":
    sample_response = """
    ```python
    import math
    result = math.sqrt(16)
    print(f"Result: {result}")
    ```
    """
    try:
        code = CodeExecutor.extract_code_snippet(sample_response)
        output = CodeExecutor.execute_safe_code(
            code, 
            allowed_keywords=['math', 'sqrt', 'print'], 
            context={}
        )
        CodeExecutor.log_execution(code, output)
    except Exception as e:
        print(f"Execution failed: {e}")
